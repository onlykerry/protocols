/***********************************************************************/
/*                                                                     */
/*   Module:  utf.c                                                    */
/*   Release: 2004.5                                                   */
/*   Version: 2004.0                                                   */
/*   Purpose: Unicode encoding related functions                       */
/*                                                                     */
/*---------------------------------------------------------------------*/
/*                                                                     */
/*               Copyright 2004, Blunk Microsystems                    */
/*                      ALL RIGHTS RESERVED                            */
/*                                                                     */
/*   Licensees have the non-exclusive right to use, modify, or extract */
/*   this computer program for software development at a single site.  */
/*   This program may be resold or disseminated in executable format   */
/*   only. The source code may not be redistributed or resold.         */
/*                                                                     */
/***********************************************************************/
#include "../posix.h"
#include "../include/fsprivate.h"
#include "../include/libc/errno.h"

#if UTF_ENABLED
/***********************************************************************/
/* Variable Declarations                                               */
/***********************************************************************/
static ui8 LengthLookup[] =
{
  1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 3, 4
};

/***********************************************************************/
/* Global Function Definitions                                         */
/***********************************************************************/

/***********************************************************************/
/*   ValidUTF8: Check if a string is properly encoded in UTF8          */
/*                                                                     */
/*      Inputs: utf8 = string to check                                 */
/*              utf8_len = length of UTF8 encoded string               */
/*                                                                     */
/*     Returns: TRUE if string UTF8 encoded, FALSE otherwise           */
/*                                                                     */
/***********************************************************************/
int ValidUTF8(const ui8 *utf8, ui32 utf8_len)
{
  ui32 code_len;
  ui8 byte1, byte2, byte3, byte4;

  /*-------------------------------------------------------------------*/
  /* Check the string is valid.                                        */
  /*-------------------------------------------------------------------*/
  if (utf8 == NULL)
    return FALSE;

  /*-------------------------------------------------------------------*/
  /* An empty string is correctly encoded.                             */
  /*-------------------------------------------------------------------*/
  if (utf8_len == 0)
    return TRUE;

  /*-------------------------------------------------------------------*/
  /* Look at the UTF8 encoded string a code at a time.                 */
  /*-------------------------------------------------------------------*/
  for (byte1 = *utf8++; utf8_len; byte1 = *utf8++)
  {
    /*-----------------------------------------------------------------*/
    /* Determine how many bytes the next UTF8 encoded code has.        */
    /*-----------------------------------------------------------------*/
    code_len = LengthLookup[(byte1 & 0xF0) >> 4];

    /*-----------------------------------------------------------------*/
    /* If the byte does not start with 0xxx or 110x or 1110 or 1111    */
    /* it's not properly formated.                                     */
    /*-----------------------------------------------------------------*/
    if (code_len == 0)
      return FALSE;

    /*-----------------------------------------------------------------*/
    /* If the code is encoded in more bytes than what is left, error.  */
    /*-----------------------------------------------------------------*/
    if (code_len > utf8_len)
      return FALSE;
    utf8_len -= code_len;

    /*-----------------------------------------------------------------*/
    /* Check code based on the number of bytes it is encoded in.       */
    /*-----------------------------------------------------------------*/
    switch (code_len)
    {
      /*---------------------------------------------------------------*/
      /* 4-byte encoding.                                              */
      /*---------------------------------------------------------------*/
      case 4:
      {
        /*-------------------------------------------------------------*/
        /* Get the next 3 bytes and advance string pointer.            */
        /*-------------------------------------------------------------*/
        byte2 = *utf8++;
        byte3 = *utf8++;
        byte4 = *utf8++;

        /*-------------------------------------------------------------*/
        /* Maximum Unicode value is 0x10FFFF. Check if code conforms.  */
        /*-------------------------------------------------------------*/
        if (byte1 > 0xF4)
          return FALSE;

        /*-------------------------------------------------------------*/
        /* Minimum 4-byte encoding is 0x10000. Check if code conforms. */
        /*-------------------------------------------------------------*/
        if (byte1 == 0xF0 && byte2 < 0x90)
          return FALSE;

        /*-------------------------------------------------------------*/
        /* Check 2nd, 3rd and 4th bytes are in valid range.            */
        /*-------------------------------------------------------------*/
        if (byte2 < 0x80 || byte2 > 0xBF ||
            byte3 < 0x80 || byte3 > 0xBF ||
            byte4 < 0x80 || byte4 > 0xBF)
          return FALSE;

        break;
      }

      /*---------------------------------------------------------------*/
      /* 3-byte encoding.                                              */
      /*---------------------------------------------------------------*/
      case 3:
      {
        /*-------------------------------------------------------------*/
        /* Get the next 2 bytes and advance string pointer.            */
        /*-------------------------------------------------------------*/
        byte2 = *utf8++;
        byte3 = *utf8++;

        /*-------------------------------------------------------------*/
        /* If code represents values between 0xD800 and 0xDFFF it's an */
        /* illegal code. These are surrogate values, not valid stand   */
        /* alone codes.                                                */
        /*-------------------------------------------------------------*/
        if (byte1 == 0xED && byte2 >= 0xA0 && byte2 <= 0xBF)
          return FALSE;

        /*-------------------------------------------------------------*/
        /* Minimum 3-byte encoding is 0x800. Check if code conforms.   */
        /*-------------------------------------------------------------*/
        if (byte1 == 0xE0 && byte2 < 0xA0)
          return FALSE;

        /*-------------------------------------------------------------*/
        /* Check 2nd and 3rd bytes are in valid range.                 */
        /*-------------------------------------------------------------*/
        if (byte2 < 0x80 || byte2 > 0xBF || byte3 < 0x80 || byte3 > 0xBF)
          return FALSE;

        break;
      }

      /*---------------------------------------------------------------*/
      /* 2-byte encoding.                                              */
      /*---------------------------------------------------------------*/
      case 2:
      {
        /*-------------------------------------------------------------*/
        /* Get the next byte and advance string pointer.               */
        /*-------------------------------------------------------------*/
        byte2 = *utf8++;

        /*-------------------------------------------------------------*/
        /* Minimum 2-byte encoding is 0x80. Check if code conforms.    */
        /*-------------------------------------------------------------*/
        if (byte1 < 0xC2)
          return FALSE;

        /*-------------------------------------------------------------*/
        /* Check 2nd byte is in valid range.                           */
        /*-------------------------------------------------------------*/
        if (byte2 < 0x80 || byte2 > 0xBF)
          return FALSE;

        break;
      }

      /*---------------------------------------------------------------*/
      /* 1-byte encoding. Nothing to do.                               */
      /*---------------------------------------------------------------*/
      case 1:
        break;

      /*---------------------------------------------------------------*/
      /* Code cannot have length other than in 1 .. 4.                 */
      /*---------------------------------------------------------------*/
      default:
        PfAssert(FALSE); /*lint !e506, !e774*/
        return FALSE;
    }
  }
  return TRUE;
}

/***********************************************************************/
/*  UTF8_UTF16: Convert a UTF8 encoded string to a UTF16 encoded one.  */
/*              The UTF8 string must be properly encoded.              */
/*                                                                     */
/*      Inputs: utf8 = original UTF8 encoded string                    */
/*              utf8_len = length of UTF8 encoded string               */
/*              utf16 = place to store the conversion                  */
/*              max_utf16_len = length (in bytes) of utf16 string      */
/*                                                                     */
/*     Returns: Length of UTF16 string, -1 on error                    */
/*                                                                     */
/***********************************************************************/
ui32 UTF8_UTF16(const ui8 *utf8, ui32 utf8_len, ui16 *utf16,
                ui32 max_utf16_len)
{
  ui32 utf16_i = 0, code_len, x2;
  ui8 byte1, byte2, byte3, byte4, u, x1;

  /*-------------------------------------------------------------------*/
  /* Check the arguments are valid.                                    */
  /*-------------------------------------------------------------------*/
  if (utf8 == NULL || utf16 == NULL || max_utf16_len == 0)
  {
    set_errno(EINVAL);
    return (ui32)-1;
  }

  /*-------------------------------------------------------------------*/
  /* An empty UTF8 string converts to an empty UTF16 string.           */
  /*-------------------------------------------------------------------*/
  if (utf8_len == 0)
    return 0;

  /*-------------------------------------------------------------------*/
  /* Go through UTF8 string code by code, converting each one.         */
  /*-------------------------------------------------------------------*/
  for (byte1 = *utf8++; utf8_len; byte1 = *utf8++, ++utf16_i, ++utf16)
  {
    /*-----------------------------------------------------------------*/
    /* If we've reached the maximum UTF16 length, out of space.        */
    /*-----------------------------------------------------------------*/
    if (utf16_i >= max_utf16_len)
    {
      set_errno(ENOSPC);
      return (ui32)-1;
    }

    /*-----------------------------------------------------------------*/
    /* Lookup the number of bytes for current code encoding.           */
    /*-----------------------------------------------------------------*/
    code_len = LengthLookup[(byte1 & 0xF0) >> 4];
    if (code_len == 0)
    {
      set_errno(EINVAL);
      return (ui32)-1;
    }
    if (code_len > utf8_len)
    {
      set_errno(EINVAL);
      return (ui32)-1;
    }
    utf8_len -= code_len;

    /*-----------------------------------------------------------------*/
    /* Convert based on code length encoding.                          */
    /*-----------------------------------------------------------------*/
    switch (code_len)
    {
      /*---------------------------------------------------------------*/
      /* 1-byte encoding.                                              */
      /*---------------------------------------------------------------*/
      case 1:
      {
        /*-------------------------------------------------------------*/
        /* This converts directly into a UTF16 code.                   */
        /*-------------------------------------------------------------*/
        *utf16 = byte1;
        break;
      }

      /*---------------------------------------------------------------*/
      /* 2-byte encoding.                                              */
      /*---------------------------------------------------------------*/
      case 2:
      {
        /*-------------------------------------------------------------*/
        /* Get the next byte and advance string pointer.               */
        /*-------------------------------------------------------------*/
        byte2 = *utf8++;

        /*-------------------------------------------------------------*/
        /* Combine the 2 bytes to get a UTF16 code.                    */
        /*-------------------------------------------------------------*/
        *utf16 = ((byte1 & 0x1F) << 6) | (byte2 & 0x3F);
        break;
      }

      /*---------------------------------------------------------------*/
      /* 3-byte encoding.                                              */
      /*---------------------------------------------------------------*/
      case 3:
      {
        /*-------------------------------------------------------------*/
        /* Get the next 2 bytes and advance string pointer.            */
        /*-------------------------------------------------------------*/
        byte2 = *utf8++;
        byte3 = *utf8++;

        /*-------------------------------------------------------------*/
        /* Combine the 3 bytes to get a UTF16 code.                    */
        /*-------------------------------------------------------------*/
        *utf16 = ((byte1 & 0xF) << 12) | ((byte2 & 0x3F) << 6) |
                 (byte3 & 0x3F);
        break;
      }

      /*---------------------------------------------------------------*/
      /* 4-byte encoding.                                              */
      /*---------------------------------------------------------------*/
      case 4:
      {
        /*-------------------------------------------------------------*/
        /* Get the next 3 bytes and advance string pointer.            */
        /*-------------------------------------------------------------*/
        byte2 = *utf8++;
        byte3 = *utf8++;
        byte4 = *utf8++;

        /*-------------------------------------------------------------*/
        /* This encoding translates into 2 UTF16 codes.                */
        /*-------------------------------------------------------------*/
        u = ((byte1 & 0x7) << 2) | ((byte2 & 0x30) >> 4);
        u -= 1;
        x1 = ((byte2 & 0xF) << 2) | ((byte3 & 0x30) >> 4);
        x2 = ((byte3 & 0xF) << 6) | (byte4 & 0x3F);

        /*-------------------------------------------------------------*/
        /* Set the first (surrogate) code of the UTF16 code.           */
        /*-------------------------------------------------------------*/
        *utf16 = 0xD800 | (u << 6) | x1;

        /*-------------------------------------------------------------*/
        /* Check there is room for the additional code.                */
        /*-------------------------------------------------------------*/
        if (++utf16_i >= max_utf16_len)
        {
          set_errno(ENOSPC);
          return (ui32)-1;
        }

        /*-------------------------------------------------------------*/
        /* Set the next code.                                          */
        /*-------------------------------------------------------------*/
        *(++utf16) = 0xDC00 | x2;
        break;
      }

      /*---------------------------------------------------------------*/
      /* Shouldn't be here.                                            */
      /*---------------------------------------------------------------*/
      default:
        PfAssert(FALSE); /*lint !e506, !e774*/
        set_errno(EINVAL);
        return (ui32)-1;
    }
  }

  return utf16_i;
}

/***********************************************************************/
/*  UTF16_UTF8: Convert a UTF16 encoded string to a UTF8 encoded one.  */
/*              The UTF16 string must be properly encoded.             */
/*                                                                     */
/*      Inputs: utf16 = original UTF16 encoded string                  */
/*              utf16_len = length of UTF16 encoded string             */
/*              utf8 = place to store the conversion                   */
/*              max_utf8_len = length (in bytes) of UTF8 string        */
/*                                                                     */
/*     Returns: Length of UTF8 string, -1 on error                     */
/*                                                                     */
/***********************************************************************/
ui32 UTF16_UTF8(const ui16 *utf16, ui32 utf16_len, ui8 *utf8,
                ui32 max_utf8_len)
{
  ui32 utf8_i, u;
  ui16 word1, word2;

  /*-------------------------------------------------------------------*/
  /* Check the arguments are valid.                                    */
  /*-------------------------------------------------------------------*/
  if (utf16 == NULL || utf8 == NULL || max_utf8_len == 0)
  {
    set_errno(EINVAL);
    return (ui32)-1;
  }

  /*-------------------------------------------------------------------*/
  /* An empty UTF16 string converts to an empty UTF8 string.           */
  /*-------------------------------------------------------------------*/
  if (utf16_len == 0)
    return 0;

  /*-------------------------------------------------------------------*/
  /* Go through UTF16 string code by code, converting each one.        */
  /*-------------------------------------------------------------------*/
  for (utf8_i = 0, word1 = *utf16++; utf16_len; word1 = *utf16++,
       --utf16_len)
  {
    /*-----------------------------------------------------------------*/
    /* If surrogate (0xD800 to 0xDFFF), UTF16 code encoded in two      */
    /* words and represents values >= 0x10000 which translate into     */
    /* 4-byte encoded UTF8 codes.                                      */
    /*-----------------------------------------------------------------*/
    if (word1 >= 0xD800 && word1 <= 0xDFFF)
    {
      /*---------------------------------------------------------------*/
      /* Check there is enough room left in UTF8 string.               */
      /*---------------------------------------------------------------*/
      if (utf8_i + 4 >= max_utf8_len)
      {
        set_errno(ENOSPC);
        return (ui32)-1;
      }
      utf8_i += 4;

      /*---------------------------------------------------------------*/
      /* Read the second UTF16 word.                                   */
      /*---------------------------------------------------------------*/
      if (utf16_len == 0)
      {
        set_errno(EINVAL);
        return (ui32)-1;
      }
      word2 = *utf16++;
      --utf16_len;

      /*---------------------------------------------------------------*/
      /* Combine the two UTF16 words to get 4 UTF8 bytes.              */
      /*---------------------------------------------------------------*/
      u = (word1 & 0x3C0) >> 6;
      ++u;
      *utf8++ = 0xF0 | ((u & 0x1C) >> 2);
      *utf8++ = 0x80 | ((u & 0x3) << 4) | ((word1 & 0x3C) >> 2);
      *utf8++ = 0x80 | ((word1 & 0x3) << 4) | ((word2 & 0x3C0) >> 6);
      *utf8++ = 0x80 | (word2 & 0x3F);
    }

    /*-----------------------------------------------------------------*/
    /* If UTF16 code less than 0x80 it's a 1-byte UTF8 encoded code.   */
    /*-----------------------------------------------------------------*/
    else if (word1 <= 0x7F)
    {
      /*---------------------------------------------------------------*/
      /* Check there is enough room left in UTF8 string.               */
      /*---------------------------------------------------------------*/
      if (++utf8_i >= max_utf8_len)
      {
        set_errno(ENOSPC);
        return (ui32)-1;
      }

      /*---------------------------------------------------------------*/
      /* Direct conversion into UTF8 code.                             */
      /*---------------------------------------------------------------*/
      *utf8++ = (ui8)word1;
    }

    /*-----------------------------------------------------------------*/
    /* If UTF16 code less than 0x800 it's a 2-byte UTF8 encoded code.  */
    /*-----------------------------------------------------------------*/
    else if (word1 <= 0x7FF)
    {
      /*---------------------------------------------------------------*/
      /* Check there is enough room left in UTF8 string.               */
      /*---------------------------------------------------------------*/
      if (utf8_i + 2 >= max_utf8_len)
      {
        set_errno(ENOSPC);
        return (ui32)-1;
      }
      utf8_i += 2;

      /*---------------------------------------------------------------*/
      /* Form the 2-byte UTF8 encoding.                                */
      /*---------------------------------------------------------------*/
      *utf8++ = 0xC0 | ((word1 & 0x7C0) >> 6);
      *utf8++ = 0x80 | (word1 & 0x3F);
    }

    /*-----------------------------------------------------------------*/
    /* Else it's a 3-byte UTF8 encoded code.                           */
    /*-----------------------------------------------------------------*/
    else
    {
      /*---------------------------------------------------------------*/
      /* Check there is enough room left in UTF8 string.               */
      /*---------------------------------------------------------------*/
      if (utf8_i + 3 >= max_utf8_len)
      {
        set_errno(ENOSPC);
        return (ui32)-1;
      }
      utf8_i += 3;

      /*---------------------------------------------------------------*/
      /* Form the 3-byte UTF8 encoding.                                */
      /*---------------------------------------------------------------*/
      *utf8++ = 0xE0 | ((word1 & 0xF000) >> 12);
      *utf8++ = 0x80 | ((word1 & 0xFC0) >> 6);
      *utf8++ = 0x80 | (word1 & 0x3F);
    }
  }
  return utf8_i;
}

#endif /* UTF_ENABLED */

